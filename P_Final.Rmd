---
title: "Trabajo final"
subtitle: Tratamiento de Datos. Grado en Ciencia de Datos- UV
author: "Equipo H"
#Pone la fecha de generación del documento
date:  "`r Sys.Date()`"  #Pondría la fecha del día actual
# Para que en lugar de "Contents" ponga "Indice" al incluir la tabla de contenido

params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"

# Por defecto se generará un salida html
# Si si quieres otras salidas o varias de ellas descomenta lo que proceda
output:
# Salida pdf. Si se incluye código en LaTex necesitarás tener instalado un compilador de Latex
  pdf_document:
    toc: yes      # Tabla de contenido (índice)
    toc_depth: 3  # Número de niveles de la tabla de contenido (índice) # 1, ##2,###3
#    number_sections: yes # Numeración de las secciones
# Salida html, 
  html_document:
    echo: yes
    number_sections: yes
    theme: lumen    # Aspecto y estilo,otras opciones: cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti 
    toc: yes
# Salida html_notebook, como html, pero con algunas opciones de visualización
  html_notebook:
    echo: yes
    number_sections: yes
    toc: yes
# Esto nos permite traducir estas etiquetas para que aparezcan en otro idioma en caso de que se usen en el documento para referenciar a figuras, tablas, etc
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---

# Introducción

En este fichero vamos analizar los datos pacientes que han usado un electro cardiograma


# Configuración del los bloques (*Chunks*)

Configuramos los bloques de código.

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}


# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)

# Opciones generales de los chucks. Se utilizarán salvo cambios en el chunk
opts_chunk$set(echo=F, message = F, error = F, warning = F, comment = NA, fig.align = 'center', dpi = 200, tidy = F, cache.path = '.cache/', fig.path = './figura/')

# Opciones generales de dígitos cuando se incluyen tablas
#options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
#knit_hooks$set(plot = knitr:::hook_plot_html)
```

# Instalación automática de paquetes

Tenemos esta parte para instalar los paquetes necesarios si es que el usuario no los tiene.

```{r}

# Especificamos las librerías necesarias en esta lista

packages = c("tidyverse","knitr","plotly")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
search()

```

#Leer ficheros binarios

En este apartado tenemos las funciones que nos permitiran leer los ficheros binarios usando la ruta

```{r}
LeerCabDig <- function(ruta) {
  #Nombramos las varibles que debe tener esta cabecera
  NomVar <- c("Dia",
              "Mes",
              "Anyo",
              "Hor",
              "Min",
              "Seg",
              "FrecMuestreo",
              "NumCanales")
  #Usamos file.path para añadir el nombre de fichero que nos interesa leer
  RD <- file.path(ruta, "cabecera_FicheroDigital.dat")
  
  #Creamos la varible que nos permita conectar con el fichero
  FichD <- file(RD, "rb")#rb es usado para indicar que es binario
  #Leemos la línea
  CabDigi <- readBin(
    FichD,
    what = integer(),
    signed = F, #indicamos que los datos son sin signo
    n = 8, #Se tratan de 8 varibles
    size = 1 #Como los datos son almacenados en 8bits lo que es 1 byte, por lo tanto size debe ser 1
  )
  Cab <- data.frame(t(CabDigi)) #Creamos un dataframe con los datos de la cabecera
  
  
  names(Cab) <- NomVar #Cambiamos los nombres
  
  close(FichD) #Cerramos el fichero
  
  
  return(Cab) #Devolvemos el data frame
  
}

LeerCabAna <- function(ruta) {
  #Declaramos el nombre de las varibles
  NomVar <- c(
    "Dia",
    "Mes",
    "Anyo",
    "Hor",
    "Min",
    "Seg",
    "ResolADC",
    "VolatageMax",
    "VoltageMin",
    "FrecMuestreo"
  )
  #Como en el caso anterior usamos el mismo metodo para leer el fichero
  RD <- file.path(ruta, "cabecera_FicheroAnalogico.dat")
  Fich <- file(RD, "rb")
  #Similar a lo de antes, pero cambia un poco, ya que el fichero, pero debemos
  #de tener en cuenta que los datos tiene un formato un poco peculiar
  CabA1 <- readBin(Fich,what = integer(),
                   signed = F,n = 7,#las 7 primeras variables deben de leerser primero
                   size = 1)#Esto se guardan en un byte
  CabA2 <- readBin(Fich,what = integer(),
                   n = 3,#El resto de variables tienen el otro formato
                   size = 2)#se almacenan en 2 bytes(16 bits)
  Cab <- data.frame(matrix(c(CabA1, CabA2), #Concatenamos las dos y generamos un data frame
                           nrow = 1))
  
  
  names(Cab) <- NomVar #Cambiamos el nombre de las varibles
  
  
  close(Fich) #Cerramos el fichero
  
  return(Cab) #Devolvemos el data frame
}

LeerFicheroAnalogico <- function(ruta) {
  Nvar <- "mv" #Nombre de la varible
  #Leemos el fichero usando el procedimeinto habitual
  RD <- file.path(ruta, "ficheroAnalogico.dat")
  N <- file.size(RD)
  fich <- file(RD, "rb")
  #Leemos todo el fichero con los datos en formato de 2 bits
  ContFich <- readBin(fich,what = integer(),
                      n = N,size = 2, signed = T)
  Cont <- data.frame(ContFich) #Creamos un dataframe
  names(Cont) <- Nvar #Cambiamos el nombre
  close(fich) #Cerramos fichero
  return(Cont) #Devolvemos el dataframe
}

LeerFicheroDigital <- function(ruta) {
  #Declaramos el nombre de las varibles.
  NVar <- c("HR1", "HR2", "MHR",
            "TOCO", "SPO2",
            "VCP", "Ps",
            "Pd", "Pm")
  #Hacemos el procedimiento habitual
  RD <- file.path(ruta, "ficheroDigital.dat")
  fich <- file(RD, "rb")
  N <- file.size(RD) #Obtenemos el tamaño del fichero para poder leerlo todo
  
  ContFich <- readBin(fich,what = integer(),
                      n = N , size = 1, signed = F)#Leemos todo, y los datos son en formato de 1 bits
  cont <-data.frame(matrix(ContFich, ncol = length(NVar), 
                           byrow = T))
  names(cont) <- NVar #Cabiamos el nombre de las variables
  close(fich)
  return(cont) #Devolvemos el data frame
  
}

#Funcion para obtener los datos de todos los ficheros
ObData <- function(ruta){
  
  CaDi <- LeerCabDig(ruta)
  DfDigital <- LeerFicheroDigital(ruta)
  CaAna <- LeerCabAna(ruta)
  DfAna <- LeerFicheroAnalogico(ruta)
  
  return(list(CaDi,DfDigital,CaAna,DfAna)) #Devolvemos una lista con todos los DF de los datos
} 


#Funcion para crear la variable tiempo del fichero digital
CrearTiempoDig <- function(df){
  # Creamos la variable del tiempo para el fichero digital 
  tiempo <- seq(0, length.out = nrow(df), by = 0.25)
  
  
  
  return(tiempo)
}


#Funcion para crear la variable tiempo del fichero Analogico
CrearTiempoAna <- function(df){
  #Frecuencia de muestreo = 1000
  Fm <- 1000
  # Creamos la variable del tiempo para el fichero Analogico 
  tiempo_analogico <- seq(from = 0, to = (nrow(df)-1)/Fm, by = 1/Fm)
  
  return(tiempo_analogico)
}

```

Ahora procederemos a leer los ficheros de la carpeta data

```{r}
#Declaramos las rutas donde estan los datos de los pacientes
rutas <- c("data/data/0519xxxiii14/06_02_2023/14.20.34",
           "data/data/0795xalvii8a7/27_09_2022/10.11.00",
           "data/data/0795xalvii8a7/27_09_2022/10.11.12",
           "data/data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO",
           "data/data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15",
           "data/data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57"
           )


#Probamos a hacer la lectura de los datos de un paciente de prueba para ver si concuerda con lo que nos deberia salir:
Datos <- ObData(rutas[4])
Cab_Dig <- as.data.frame(Datos[1])
Datos_Dig <- as.data.frame(Datos[2])
Cab_Ana <- as.data.frame(Datos[3])
Datos_Ana <- as.data.frame(Datos[4])

#Creamos la variable tiempo para los datos digitales
tiempo <- CrearTiempoDig(Datos_Dig)
#Añadimos la variable tiempo a nuestro df de datos digitales
Datos_Dig <- Datos_Dig %>% mutate(tiempo = tiempo)

#Creamos la variable tiempo para los datos Analogicos
tiempo <- CrearTiempoAna(Datos_Ana)
#Añadimos la variable tiempo a nuestro df de datos Analogicos
Datos_Ana <- Datos_Ana %>% mutate(tiempo = tiempo)
```

Ahora vamos a unirlo todo:

```{r}
#REPRESENTACION

#GRAFICO FICHERO DIGITAL

#Nos quedamos con los datos con el tiempo por debajo de 301
datos_Dig_300 <- Datos_Dig %>% select(everything()) %>% filter(tiempo <= 300)

#Adaptamos los datos para poder representarlos:
datos_Dig_300 <- gather(datos_Dig_300, key = "Tipo", value = "value", -tiempo)

#Representamos todas las variables en funcion del tiempo:
ggplot(datos_Dig_300, aes(x = tiempo, y = value, color = Tipo)) + 
  geom_line() + 
  facet_wrap(~ Tipo, scales = "free") + 
  labs( x = "Tiempo", y = "Valor")

#GRAFICO FICHERO ANALÓGICO

#Obtenemos los ultimos 9 segundos de la señal
Datos_Ana_9 <- Datos_Ana %>% select(everything()) %>% filter(tiempo> max(tiempo)-9)
#Representamos los ultimos 9 segundos de la señal
g <- ggplot(Datos_Ana_9, aes(x = tiempo, y = mv)) + 
  geom_line(col="blue") +
  labs(title = "Fichero Analogico", x = "time", y = "data") 

ggplotly(g)

#Vemos que los resultados concuerdan con el modelo proporcionado

```
#Detección de datos anomalos y faltantes
En esta parte comprobaremos la presencia de datos faltantes y de outliers, para ello ejecutaremos este código.
```{r}
#Primero miraremos si exiten algun NA en nuestros datos
#Una vez creado el data frame, debemos indagar para, en el caso de que halla, 
#encontrar los datos faltantes, esto lo llevaremos a cabo mediante
#la función is.na:
#Devolverá un vector lógico de la misma longitud que el vector o columna que se está verificando, donde cada elemento será TRUE si el valor correspondiente es faltante,
#y FALSE en caso contrario.

#Vemos cada variable con respecto al data frame:
datos_faltantes1<-is.na(df$HR1)
datos_faltantes1

datos_faltantes2<-is.na(df$HR2)
datos_faltantes2

datos_faltantes3<-is.na(df$MHR)
datos_faltantes3

datos_faltantes4<-is.na(df$TOCO)
datos_faltantes4

datos_faltantes5<-is.na(df$SPO2)
datos_faltantes5

datos_faltantes6<-is.na(df$VCP)
datos_faltantes6

datos_faltantes7<-is.na(df$Ps)
datos_faltantes7

datos_faltantes8<-is.na(df$Pd)
datos_faltantes8

datos_faltantes9<-is.na(df$Pm)
datos_faltantes9

datos_faltantes10<-is.na(df$HR1.1)
datos_faltantes10

datos_faltantes10<-is.na(df$HR2.1)
datos_faltantes10

datos_faltantes11<-is.na(df$MHR.1)
datos_faltantes11

datos_faltantes12<-is.na(df$TOCO.1)
datos_faltantes12

datos_faltantes13<-is.na(df$SPO2.1)
datos_faltantes13

datos_faltantes14<-is.na(df$VCP.1)
datos_faltantes14

datos_faltantes15<-is.na(df$Ps.1)
datos_faltantes15

datos_faltantes16<-is.na(df$Pd.1)
datos_faltantes16

datos_faltantes17<-is.na(df$Pm.1)
datos_faltantes17

datos_faltantes18<-is.na(df$FrecMuestreo)
datos_faltantes18

datos_faltantes19<-is.na(df$NumCanales)
datos_faltantes19

datos_faltantes20<-is.na(df$ResolADC)
datos_faltantes20

datos_faltantes21<-is.na(df$VolatageMax)
datos_faltantes21

datos_faltantes22<-is.na(df$VolatageMin)
datos_faltantes22

datos_faltantes23<-is.na(df$FrecMuestreo.1)
datos_faltantes23

datos_faltantes24<-is.na(df$Fecha)
datos_faltantes24

datos_faltantes25<-is.na(df$Hora)
datos_faltantes25

#Como resulta todo FALSE no hay ningún dato faltante

#Ahora lo que si es posible ver es que hay valores que no tienen muchos sentido, ya que hay valores de 0 en cosas como los latidos por minuto, o presión sanguinia, lo cual no tiene mucho sentido, por lo tanto esos datos los convertiremos en NAs para no tomarlos muy encuenta
#Además aplicaremos algún metodo para comprobar que si hay más valores extraños, para lo cual definiremos las siguientes funciones
#Definimos la función para dectectar outliers 
# MADM median absolute deviation from the median
madm <- function(x, na.rm = T) {  
  if (na.rm){
    x <- x[!is.na(x)]
  }
  res <- 1.4826 * median(abs(x - median(x)))
  return(res)
}
Estadisticos <- function(x, na.rm = T){
  if (na.rm){
    x <- x[!is.na(x)]
  }
  m <- mean(x)
  n <- length(x)
  s <- sd(x)
  Q <- IQR(x)
  MADM <- madm(x)
  return(c(median = m,length = n, SD = s, IQR = Q,madm = MADM))
  
}

# Regla 3 sigma
reglasigma <- function(x,na.rm = T) { 
  rest1 <- Estadisticos(x)[1]
  rest2 <-Estadisticos(x)[3]
  return(x < rest1 - 3*madm(x) | x > rest1 + 3 * rest2)
  }

# Identificador Hampel
reglahampel <- function(x, na.rm = T) {  
  
  return( x < median(x, na.rm = T) - 3*madm(x, na.rm = T) | 
            x > median(x, na.rm = T) + 3*madm(x, na.rm = T))
  }

# Regla boxplot
reglaboxplot <- function(x,na.rm = T) {
  return(x < quantile(x, 1/4, na.rm = T) - 1.5 *IQR(x, na.rm = T) |
           x > quantile(x, 3/4, na.rm = T) + 1.5 *IQR(x, na.rm = T))
  }
# Percentiles
reglapercentil <- function(x) {  
  return(x < quantile(x, 0.05, na.rm = T) | x > quantile(x, 0.05, na.rm = T))
}

metodos <- list(reglasigma=reglasigma,reglahampel=reglahampel,reglaboxplot=reglaboxplot,reglapercentil=reglapercentil)

summary(Pas1[[2]]) #Podemos ver que HR2, HR1, Toco,ps,pd,pm tiene valores minimos de 0, lo cual sabemos que nos es posibel, ya que correcponden a los latidos del corazón y o presión de diferentes partes del cuerpo
#Lo ideal sería nobralos como NA
r <- Pas1[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  
Pas1[[2]] <- r
summary(Pas1[[2]])

summary(Pas1[[4]]) #Parece normal

#Ahora hacemos esto para cada paciente
r <- Pas2[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  

Pas2[[2]] <- r
summary(Pas2[[2]])

summary(Pas2[[4]]) #Parece normal

r <- Pas3[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  
Pas3[[2]] <- r
summary(Pas3[[2]])

summary(Pas3[[4]]) #Parece normal

r <- Pas4[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  
Pas4[[2]] <- r
summary(Pas4[[2]])

summary(Pas4[[4]]) #Parece normal

r <- Pas5[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  
Pas5[[2]] <- r
summary(Pas5[[2]])

summary(Pas5[[4]]) #Parece normal


r <- Pas6[[2]]
r<-r %>%
  mutate(HR1 = ifelse(HR1 == 0,NA,HR1)) %>%
  mutate(HR2 = ifelse(HR2 == 0,NA,HR2)) %>%
  mutate(TOCO = ifelse(TOCO == 0,NA,TOCO)) %>%
  mutate(Ps = ifelse(Ps == 0,NA,Ps)) %>%
  mutate(Pd = ifelse(Pd == 0,NA,Pd)) %>%
  mutate(Pm = ifelse(Pm == 0,NA,Pm))
  
summary(r)
#Usamos las funciones para comprobar la presencia de outliers
r %>%
  summarise(across(everything(), metodos))
  
Pas6[[2]] <- r
summary(Pas6[[2]])

summary(Pas6[[4]]) #Parece normal

#Podemos ver que esto nos esta arrojando resultados variables, pero es lo normal debido a que los muchos de estos metodos discrimina mucho, pero podemos ver que las reglas de hampel no detectan outliers lo cual si vemos los datos parece ser lo más compresible
```



