---
title: "Trabajo final"
subtitle: Tratamiento de Datos. Grado en Ciencia de Datos- UV
author: "Equipo H"
#Pone la fecha de generación del documento
date:  "`r Sys.Date()`"  #Pondría la fecha del día actual
# Para que en lugar de "Contents" ponga "Indice" al incluir la tabla de contenido

params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"

# Por defecto se generará un salida html
# Si si quieres otras salidas o varias de ellas descomenta lo que proceda
output:
# Salida pdf. Si se incluye código en LaTex necesitarás tener instalado un compilador de Latex
  pdf_document:
    toc: yes      # Tabla de contenido (índice)
    toc_depth: 3  # Número de niveles de la tabla de contenido (índice) # 1, ##2,###3
#    number_sections: yes # Numeración de las secciones
# Salida html, 
  html_document:
    echo: yes
    number_sections: yes
    theme: lumen    # Aspecto y estilo,otras opciones: cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti 
    toc: yes
# Salida html_notebook, como html, pero con algunas opciones de visualización
  html_notebook:
    echo: yes
    number_sections: yes
    toc: yes
# Esto nos permite traducir estas etiquetas para que aparezcan en otro idioma en caso de que se usen en el documento para referenciar a figuras, tablas, etc
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---

# Introducción

En este fichero vamos analizar los datos pacientes que han usado un electro cardiograma


# Configuración del los bloques (*Chunks*)

Configuramos los bloques de código.

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}


# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)

# Opciones generales de los chucks. Se utilizarán salvo cambios en el chunk
opts_chunk$set(echo=F, message = F, error = F, warning = F, comment = NA, fig.align = 'center', dpi = 200, tidy = F, cache.path = '.cache/', fig.path = './figura/')

# Opciones generales de dígitos cuando se incluyen tablas
#options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
#knit_hooks$set(plot = knitr:::hook_plot_html)
```

# Instalación automática de paquetes

Tenemos esta parte para instalar los paquetes necesarios si es que el usuario no los tiene.

```{r}

# Especificamos las librerías necesarias en esta lista

packages = c("tidyverse","knitr")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
search()

```

#Leer ficheros binarios

En este apartado tenemos las funciones que nos permitiran leer los ficheros binarios usando la ruta

```{r}
LeerCabDig <- function(ruta) {
  #Nombramos las varibles que debe tener esta cabezera
  NomVar <- c("Dia",
              "Mes",
              "Anyo",
              "Hor",
              "Min",
              "Seg",
              "FrecMuestreo",
              "NumCanales")
  #Usamos file.path para añadir el nombre de fichero que nos interesa leer
  RD <- file.path(ruta, "cabecera_FicheroDigital.dat")
  
  #Creamos la varible que nos permita conectar con el fichero
  FichD <- file(RD, "rb")#rb es usado para indicar que es binario
  #Leemos la línea
  CabDigi <- readBin(
    FichD,
    what = integer(),
    signed = F, #indicamos que los datos son sin signo
    n = 8, #Se tratan de 8 varibles
    size = 1 #Como los datos son almacenados en 8bits lo que es 1 byte, por lo tanto size debe ser 1
  )
  Cab <- data.frame(t(CabDigi)) #Creamos un dataframe con los datos de la cabecera
  
  
  names(Cab) <- NomVar #Cambiamos los nombres
  
  close(FichD) #Cerramos el fichero
  
  
  return(Cab) #Devolvemos el data frame
  
}

LeerCabAna <- function(ruta) {
  #Declaramos el nombre de las varibles
  NomVar <- c(
    "Dia",
    "Mes",
    "Anyo",
    "Hor",
    "Min",
    "Seg",
    "ResolADC",
    "VolatageMax",
    "VoltageMin",
    "FrecMuestreo"
  )
  #Como en el caso anterior usamos el mismo metodo para leer el fichero
  RD <- file.path(ruta, "cabecera_FicheroAnalogico.dat")
  Fich <- file(RD, "rb")
  #Similar a lo de antes, pero cambia un poco, ya que el fichero, pero debemos
  #de tener en cuenta que los datos tiene un formato un poco peculiar
  CabA1 <- readBin(Fich,what = integer(),
                   signed = F,n = 7,#las 7 primeras variables deben de leerser primero
                   size = 1)#Esto se guardan en un byte
  CabA2 <- readBin(Fich,what = integer(),
                   n = 3,#El resto de variables tienen el otro formato
                   size = 2)#se almacenan en 2 bytes(16 bits)
  Cab <- data.frame(matrix(c(CabA1, CabA2), #Concatenamos las dos y generamos un data frame
                           nrow = 1))
  
  
  names(Cab) <- NomVar #Cambiamos el nombre de las varibles
  
  
  close(Fich) #Cerramos el fichero
  
  return(Cab) #Devolvemos el data frame
}
```

